package main;

import java.io.File;
import java.util.LinkedList;
import java.util.List;

import org.key_project.util.collection.DefaultImmutableSet;
import org.key_project.util.collection.ImmutableList;
import org.key_project.util.collection.ImmutableSet;

import de.uka.ilkd.key.java.*;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.abstraction.Type;
import de.uka.ilkd.key.java.declaration.LocalVariableDeclaration;
import de.uka.ilkd.key.java.declaration.ParameterDeclaration;
import de.uka.ilkd.key.java.expression.operator.Conditional;
import de.uka.ilkd.key.java.expression.operator.Equals;
import de.uka.ilkd.key.java.reference.ExecutionContext;
import de.uka.ilkd.key.java.reference.TypeRef;
import de.uka.ilkd.key.java.statement.MethodFrame;
import de.uka.ilkd.key.logic.JavaBlock;
import de.uka.ilkd.key.logic.NamespaceSet;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.op.IProgramMethod;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.InitConfig;
import de.uka.ilkd.key.proof.init.JavaProfile;
import de.uka.ilkd.key.proof.init.ProblemInitializer;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.proof.io.AbstractEnvInput;
import de.uka.ilkd.key.speclang.PositionedString;
import xml.*;

public class JavaExpressionReader {
  
    private final String javaPath; 
    private final List<File> classPath;
    private final File bootClassPath;

    private final String classContext;

    private final String methodContext;
    
    /**
     * creates an expression reader
     * @param javaPath path to the Java source classes 
     * @param classPath path to the external libraries (source or bytecode)
     * @param bootClassPath path to the JDK classes (STUBS!  generated by KeY)
     * @param classContext the fully qualified class name in which scope the classes shall be parsed
     * @param methodContext the full method signature
     */
    public JavaExpressionReader(String javaPath, 
            List<File> classPath,
            File bootClassPath,
            String classContext,
            String methodContext) {
        
        this.javaPath = javaPath;
        this.classPath = classPath;
        this.bootClassPath = bootClassPath;
        
        this.classContext  = classContext;
        this.methodContext = methodContext; 
    }

    public KeYJavaType getKeYJavaTypeForExpression(String expressionToRead) throws ProofInputException {
        final InitConfig ic = getInitConfig();        
        final Services services = ic.getServices();
        final JavaInfo javaInfo = services.getJavaInfo();
        
        
        KeYJavaType classContextKJT = javaInfo.getKeYJavaType(classContext);        
        if (classContextKJT == null) {
            throw new IllegalStateException("Could not find a class named " + classContext + ". Please check your path settings.");
        }
                
        LocationVariable self = new LocationVariable(new ProgramElementName("self$1"), classContextKJT);
                
        IProgramMethod method = null;
        if (methodContext != null) {
            // TODO: In general you need here to get the most specific method
            // use one of " javaInfo.getProgramMethod(classType, methodName, signature, context)"
            // to get the method with the exact signature
            // Here I assume no overloading happened
            
            ImmutableList<IProgramMethod> allMethods = javaInfo.getAllProgramMethods(classContextKJT);
            for (IProgramMethod m : allMethods) {
                if (m.getFullName().equals(methodContext)) {
                    method = m;
                    break;
                }
            }
        }
                        
        String methodSignature  = "m()";
        if (method != null) {
            String arguments = "";
            for (int i = 0; i < method.getParameters().size(); i++) {                   	 
            	arguments += method.getParameterType(i).getSort().toString();
            	if (i != method.getParameters().size() - 1)
            		arguments += ",";
            }    
            methodSignature = method.getFullName() + "(" + arguments + ")";            
        }
        
        String methodFrameHeader = "method-frame(source=" + methodSignature + "@" + classContext + "):";        
        String methodFrame = methodFrameHeader + "{  boolean b = " + expressionToRead + " == " + expressionToRead + " ? true : false; }";
        
        NamespaceSet nss = services.getNamespaces().copy();
        nss.programVariables().add(self);
        
        if (method != null) {
            for (ParameterDeclaration param : method.getParameters()) {
                nss.programVariables().add(param.getVariableSpecification().getProgramVariable());
            }
        }

        Recoder2KeY r2k = new Recoder2KeY(services, nss);
        JavaBlock parsedBlock  = r2k.readBlockWithProgramVariables(nss.programVariables(), "{" + methodFrame + "}");
        
        
        Expression e = extractExpression(parsedBlock);
        
        return e.getKeYJavaType(ic.getServices(), new ExecutionContext(new TypeRef(classContextKJT), null, null));
    }

    private Expression extractExpression(JavaBlock parsedBlock) {
        final StatementBlock blockAST = (StatementBlock)parsedBlock.program();        
        final MethodFrame methodFrameAsAST = (MethodFrame)blockAST.getBody().get(0);
        final LocalVariableDeclaration localVariableDeclarationOfBooleabVariableB = (LocalVariableDeclaration)(methodFrameAsAST.getBody().getStatementAt(0));
        final Conditional initializerOfVariableB = (Conditional)localVariableDeclarationOfBooleabVariableB.getVariableSpecifications().get(0).getInitializer();
        return ((Equals)initializerOfVariableB.getExpressionAt(0)).getExpressionAt(0);
    }

    private InitConfig getInitConfig() throws ProofInputException {
        MyEnvInput env = new MyEnvInput("testExprReader", javaPath, classPath, bootClassPath);
        ProblemInitializer pi = new ProblemInitializer(env.getProfile());
        InitConfig ic = pi.prepare(env);
        return ic;
    }

    
    public static void main(String[] args) throws ProofInputException {
    	String[] address = new String[2];    	
     	address[0] = "/home/chimento/repos/JER/example/tmp.xml";
     	address[1] = "/home/chimento/Example/out/";
     	
    	try {
    		run(address);
         }
         catch (Exception e) {
            e.printStackTrace();
         }    	        
    	    	
    	String workingDirectory = System.getProperty("user.dir");
    	
        JavaExpressionReader jer = new JavaExpressionReader("/home/chimento/repos/JER/example/src/", 
                new LinkedList<File>(), new File(workingDirectory + "/jre"), "main.CMachine", "setCups");
        
        try {
            System.out.println("Expression Type: " + jer.getKeYJavaTypeForExpression("limit + foo.goo.goo()").getJavaType().getFullName());
        } catch (ProofInputException pie) {
            System.out.println(pie.line + ":" + pie.charPositionInLine);
            throw pie;
        } catch (RuntimeException e) {        	
        	System.out.println(e.toString());        	
        }
       
        jer = new JavaExpressionReader("/home/chimento/repos/JER/example/src/", 
                new LinkedList<File>(), new File(workingDirectory + "/jre"), "main.CMachine", "setCups");
        
        try {
            System.out.println("Expression Type: " + jer.getKeYJavaTypeForExpression("foo.goo").getJavaType().getFullName());
        } catch (ProofInputException pie) {
            System.out.println(pie.line + ":" + pie.charPositionInLine);
            throw pie;
        }
       /*  
        jer = new JavaExpressionReader("/home/chimento/repos/JER/example/src/", 
                new LinkedList<File>(), new File("./jre"), "main.CMachine", "setCups");
                
        try {
            System.out.println("Expression Type: " + jer.getKeYJavaTypeForExpression("limit + y").getJavaType().getFullName());
        } catch (ProofInputException pie) {
            System.out.println(pie.line + ":" + pie.charPositionInLine);
            throw pie;
        } catch (ConvertException e) {
        	System.out.println("An error has occur while infering a type: ");
        	//e.printStackTrace();
        	System.out.println(e.getCause());
        }
        */
    }    
    
    public static void run(String[] args) throws Exception { 
    	if (args.length == 2) {
    		String arg = args[0];
            File file = new File(arg);
            
            File resultFile;
            if (arg.charAt(arg.length()-1) == '/') {               
                resultFile = new File(args[1] + "tmp2.xml");                  
             } else {
                resultFile = new File(args[1] + "/tmp2.xml");
             }
            
            if (file.exists()) {
               Result result = Reader.load(file);
               try {
               	for (OldExpr old : result.getOldExpr()) {               	   
          	       inferTypes(old,args[1]+"/workspace/files/");          	       
          	    }            
               } catch (ProofInputException pie) {
                   System.out.println(pie.line + ":" + pie.charPositionInLine);
                   throw pie;
               }
               Writer.write(result, resultFile);   
            }
            else {
               throw new RuntimeException("The file \"" + file + "\" does not exist.");
            }
        }
    }
    
    public static void inferTypes(OldExpr oexpr,String path) throws Exception {    	
    	JavaExpressionReader jer = new JavaExpressionReader(oexpr.getPath(), 
                //new LinkedList<File>(), new File(oexpr.getPath()), oexpr.getTarget(), oexpr.getMethodName());    	
    			new LinkedList<File>(), new File("./jre"), oexpr.getTarget(), oexpr.getMethodName());
    	String type = null;
    	
        	for (OExpr oe : oexpr.getOexprs()) {
        		if (oe.getType().equals("")){
        			System.out.println("Checking type of expression: " + oe.getExpr());
        			
        			try {
        			     type = jer.getKeYJavaTypeForExpression(oe.getExpr()).getJavaType().getFullName();
        			     String[] aux = type.split("\\.");
        			     oe.setType(aux[aux.length-1]);
        			} catch (ProofInputException pie) {
        	            System.out.println(pie.line + ":" + pie.charPositionInLine);
        	            throw pie;
        	        } catch (RuntimeException e) {
        	        	;	
        	        } 
       	            if (type==null)
       	               oe.setType("Type inference failure.");       	            
        		} 	            
   	         }            
    }
    
    private class MyEnvInput extends AbstractEnvInput {

        public MyEnvInput(String name, 
                String javaPath, 
                List<File> classPath,
                File bootClassPath) {
            super(name, javaPath, classPath, bootClassPath, 
                    JavaProfile.getDefaultInstance(), new LinkedList<File>());
        }
        
        @Override
        public ImmutableSet<PositionedString> read()
                throws ProofInputException {
            return DefaultImmutableSet.<PositionedString>nil();
        }

        @Override
        public File getInitialFile() {
            return null;
        }       
    }  
}